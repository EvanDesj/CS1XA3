# CS1XA3 Project03 - desjarde

## Usage
To begin, you need to use the anaconda to create a django environment. If you do not have Anaconda, follow [this](https://problemsolvingwithpython.com/01-Orientation/01.03-Installing-Anaconda-on-Windows/) this tutorial to download it, and then follow [this](https://www.pythonistaplanet.com/how-to-create-a-django-project-in-anaconda-very-easily/) tutorial to create a Django environment inside anaconda.
The next step is to clone the git repository that contains Project03 to the desired location on your machine. First, go to wherever you would like to clone the repo, then enter `git clone https://github.com/EvanDesj/CS1XA3.git` From here, `cd CS1XA3/Project03` to get into the project, where the manage.py file can be found. Always make sure to activate your django environment, (using `conda activate (name of your django environment here)` when you are trying to run the server! Then, to run Project03 locally, type `python manage.py runserver localhost:8000` when in the same directory as the manage.py file to run the server. Now, opening the web browser of your choice, you'll be able to find the website at [localhost:8000/e/desjarde](localhost:8000/e/desjarde) and begin using it. On the other hand, if you are running the project from the mac1xa3 server, then enter `python manage.py runserver localhost:10022` when in the same directory as the manage.py file, and go to https://mac1xa3.ca/e/desjarde/
Once at the login page, you can make a new account by clicking on the "Create An Account" button and entering a valid username and password. As soon as the account is created you will be logged into the messages page on the site. On the left column the user profile is displayed, with initially unspecified and blank values. At the top of the middle column the user can post to the messages section of the page, which are viewable by all the other users on the platform. In the right column friend's are shown as you begin to send and accept friend requests from other users. To begin, click the top right corner to access the account page. Here the account password can be changed if necessary, and user employment, location, birthday and interests can be added to their profile. The forms are simply enter the desired input and click update to change from the default values. To see other user's accounts, you can click on the person icon in the bar across the top of the page. This is where other users can be found to add as friends, as well as accepting or declining incoming friend requests. Anyone who is not currently the user's friend is displayed in the middle column, which can be expanded by pressing the more button. The right hand side is where friend requests appear, along with a green check mark or red x icon which can be used to respond to the request. Lastly, to logout of the user's account and be sent back to the login screen, click the logout button in the top left corner of the page.

## Objective 01
The goal for this objective was to create a working page for making new accounts for the website. This was achieved inside the login app using a User Creation Form, which was then give to the signup.djhtml template (found at login/templates/signup.djhtml) in the context of the signup_view function (found in login/views.py). After information is put in the form and submitted, it is posted to the create_view function, where the input is checked to see if it is valid. If so, a new UserInfo object (full details on the project's models can be found in social/models.py) is created with the username and password that had been entered, and the user is redirected to the messages page inside the social app. Any exceptional cases are handled by the User Creation Form itself for this objective.

## Objective 02
This objective was the creation of the user profile on the left side of the messages screen, the first page that is shown when logging in. To do this, django template variables were used to get attributes from the currently logged in user, which is given the name user_info in the views.py file, and given in the context to each of the .djhmtl files in the templates folder. Thus, to get the desired information, user_info.employment, user_info.location and user_info.birthday were used to get the desired information, using double curly brackets {{...}} to signify a template variable in the file. To show all interests, a for loop was used to go through the list of interests and display a span with each one inside.

## Objective 03
For this objective, forms were created to change the user's password, as well as edit the various parts of their profile. To change the password, a Password Change Form from Django was used, once again being given to the account.djhtml file, found at social/templates/account.djhtml, in the context of the account_view function in social/views.py. If a POST request is sent from the account page, then the password form is checked to see if the entries were valid. If so, the password of the user is updated and the password form returns to blank. If there are errors in the password change in any way, the password change form handles them and puts out a corresponding error message. For the Update Info section of the Account Page, four forms were created inside the account.djhtml template, which I learned how to make from [here]([https://docs.djangoproject.com/en/3.0/topics/forms/](https://docs.djangoproject.com/en/3.0/topics/forms/)) Each of these forms has a hidden input named formtype, with corresponding values, and depending on which form is updated, the POST request to account_view can be managed in this way to update the proper attribute of the user. Initially, these fields start out as "Unspecified" for location and employment, with no birthday or interests. All fields will not update to an empty string, and appropriate error messages will appear if this is tried, although multiple spaces are not prevented. Birthday does not update if the format is not entered properly into the date form, bringing up an error message, and duplicate interests cannot be added to the same profile either. 

## Objective 04
The goal of this objective was to show any users in the database that aren't friends of the current user on the people page, which is accessed by clicking on the person across the top bar of the page. This is done in the people_view function in social/views.py by querying for a list of all the users in the database except for the user itself, then checking if each of those users are not friends of the current user, and if so, adding them to a not_friends list. The not_friends list's length is determined by the session variable show_people, (which I learned how to use from [here](https://django-book.readthedocs.io/en/latest/chapter14.html) and [here](https://docs.djangoproject.com/en/3.0/topics/http/sessions/)) which is initialized to one and incremented by one by the more_ppl_view function, also in social/views.py, each time the more button on the people page is clicked. This is because the more button is linked to send an AJAX POST by the submitMorePpl function in the people.js file, found at social/static/people.js, to the more_ppl_view function, and then the page is reloaded upon success. Next, the not_friend's list is given to the people.djhtml template in the context, and looped through to create each of the suggested profiles, including the relevant information for each profile with Django template variables in the same way as Objective 02.  If the user logs out of their account, the show_people session variable is reset by the logout_view function in login/views.py.

## Objective 05
This objective allowed the friend request button to send friend requests to other user's on the platform. First, each friend request button has the id of the person who the request is being sent to, which sends an AJAX POST using the friendRequest function in people.js to the friend_request_view function in social/views.py . There, the username of the person the request was sent to is taken from the post, then a FriendRequest object is created, which can be seen inside social/models.py, with the appropriate to and from user attributes. Once a friend request has been sent, the friend request button for each of the people involved in the request is disabled, as an answer from the receiving user is awaited. Friend requests are shown in the right column of the people page of the receiving account. These are displayed by looping through all the friend requests a user has, which is found by querying the FriendRequest objects in the people_view function, passing that list to the people.djhtml template in the context, and showing the needed amount of friend requests.

## Objective 06
The goal for this objective was to enable accepting or declining friend requests that have been sent. The accept and decline buttons each have id's that contain the username of the user who sent the friend request. On clicking either accept or decline, an id the distinguishes between the decision with the sender's name is sent by AJAX POST in the people.js file, found in social/static/people.js, and the information is taken to the accept_decline_view function in social/views.py. This function splits the id into A or D and the sender's username, then the FriendRequest object is found, and based on the user's decision, the user's are either added as friends or not, and the FriendRequest object is deleted.

## Objective 07
This objective was to show all the user's friends in the right column of the messages page. To do so, a list of all the friends of the user is found in the messages_view function, which is then passed to the messages.djhtml file in the context, and looped through to display each of the friends, showing their names under their profile picture.

## Objective 08
This objective enabled the ability for users to post to the messages page. To do so, on the press of the post button, the submitPost function in messages.js gets the content of the post box using it's Id, where it is sent as a POST to the post_submit_view in social/views.py. The post contents is turned into a Post object, which can be found in the social/models.py file, setting the owner to be the current user who posted the message. Then on success the page is reloaded. The posts have a couple of bugs that I did not managed to fix, as every enter click adds a <br> tag to the end of the post, which I was not always able to remove. Even though the enter key is disabled through the javascript at the top of messages.js, which was found from [here](https://stackoverflow.com/questions/18552336/prevent-contenteditable-adding-div-on-enter-chrome), 1 tag can still be added. As well, entering lots of spaces and enters creates unwanted '&nbsp' in the post, which I was not able to remove either.

## Objective 09
This objective allowed the real user posts to be shown on the messages page. In the messages_view, a list of all the post objects, sorted from newest to oldest using order_by(-timestamp), [found here](https://stackoverflow.com/questions/30314741/django-date-query-from-newest-to-oldest) are generated and passed to the messages.djhtml in context, which are looped through to show various user posts. Similarly to Objective 04, where the user clicked more to show more possible friends, the more button increments the session variable post_amount by one each time using an AJAX POST from the submitMore function in messages.js to the more_post_view function in social/views.py. This variable is used to determine the length of the posts list given to the messages.djhtml file, and also resets when the user logs out by the login_view function in login/view.py.

## Objective 10
For this objective, the like button was enabled. To do so, the submitLike() function in the messages.js file was created to get the id of the like button clicked, which contains the Id of the post it is associated with. This is sent as a POST to like_view in social/views.py, where the post associated with that like button is found, and the current user is added to the likes attribute of the post. Once a post has been liked, the user cannot like again, so the button is disabled. To check this when finding the list of posts to give to the template for showing, each post is checked to see whether the current user has liked the post or not, and if so, the liked attribute on the post is set to True and the button is disabled. The like count is updated by counting the number of UserInfo objects in the likes attribute of the post.

## Objective 11
This objective was to create the test database which is gone over in the usage section to demonstrate all the functionality created in the previous 10 objectives, summarizing and showcasing this project.
If you want to use any of the sample test subjects, here is a table of their username's and passwords:

Username: BeardedMan
Password: ilovelogs1

Username: Jim
Password: coolguy78

Username: Joe
Password: compsciguy

Username: Jennifer
Password: compscigirl

Username: Sally
Password: horsegirl6

BeardedMan displays the friends in the right hand column of the messages page, and he has liked a couple posts, showing the disabled like button afterwards.
Jim displays what it looks like to have friend requests on the people page, and it can also be seen that each of the people who are requesting to be his friend have the request button disabled, if the decline button is clicked the friend request button will be reactivated, if the accept button is clicked then that person will be removed from the middle column of the people page.
The rest of the people in the system have each posted, which can be seen by clicking more on the messages page. Plus, they all have their own interests and occupations set.
Multiple users can share interests, as the same interest from the interest class is set into their own interests attribute, which means there is no unique constraint error. 



